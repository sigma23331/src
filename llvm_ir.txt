declare i32 @getint()
declare void @putint(i32 )
declare void @putstr(i8* )

@.str.0 = private unnamed_addr constant [10 x i8] c"22376286\0A\00"
@.str.1 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.2 = private unnamed_addr constant [11 x i8] c"globalVar=\00"
@.str.3 = private unnamed_addr constant [17 x i8] c"calculateFunc()=\00"
@.str.4 = private unnamed_addr constant [15 x i8] c"declareFunc()=\00"
@.str.5 = private unnamed_addr constant [3 x i8] c"0\0A\00"
@.str.6 = private unnamed_addr constant [3 x i8] c"1\0A\00"
@.str.7 = private unnamed_addr constant [3 x i8] c"2\0A\00"
@.str.8 = private unnamed_addr constant [6 x i8] c"sum1=\00"

@globalVar = dso_local global i32 0
@var6 = dso_local global i32 0
@globalVar1 = dso_local global i32 0
@globalVar2 = dso_local global i32 0
@vec = dso_local global [10 x i32] [i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0]
@vec1 = dso_local global [10 x i32] [i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0]
@const0 = dso_local constant i32 0
@const12 = dso_local constant [2 x i32] [i32 1, i32 2]
@const3 = dso_local constant i32 3
@declareFunc.var0 = dso_local global i32 0
@declareFunc.vars1 = dso_local global [10 x i32] [i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0]
@declareFunc.var22 = dso_local global i32 0
@shortPath.sum3 = dso_local global i32 0

define dso_local void @declareFunc() {
entry0:
	%var3.addr.0 = alloca i32
	%var4.addr.1 = alloca i32
	%var5.addr.2 = alloca i32
	store i32 1, i32* %var4.addr.1
	store i32 1, i32* @declareFunc.var0
	%v3 = load i32, i32* @const0
	%v4 = getelementptr inbounds [10 x i32], [10 x i32]* @declareFunc.vars1, i32 0, i32 0
	store i32 %v3, i32* %v4
	ret void
}

define dso_local i32 @shortPath(i32 %v0) {
entry0:
	%a.addr.1 = alloca i32
	store i32 %v0, i32* %a.addr.1
	%v2 = load i32, i32* @shortPath.sum3
	%v3 = add i32 %v2, 1
	store i32 %v3, i32* @shortPath.sum3
	%v4 = load i32, i32* @shortPath.sum3
	ret i32 %v4
}

define dso_local i32 @caculateFunc(i32 %v0, i32 %v1, i32* %v2) {
entry0:
	%a.addr.3 = alloca i32
	%b.addr.4 = alloca i32
	%i.addr.17 = alloca i32
	store i32 %v0, i32* %a.addr.3
	store i32 %v1, i32* %b.addr.4
	%v5 = load i32, i32* %a.addr.3
	%v6 = load i32, i32* %b.addr.4
	%v7 = icmp sgt i32 %v5, %v6
	br i1 %v7, label %if.then1, label %if.follow2
if.then1:
	ret i32 0
if.follow2:
	%v8 = load i32, i32* %a.addr.3
	%v9 = load i32, i32* %b.addr.4
	%v10 = icmp ne i32 %v8, %v9
	br i1 %v10, label %if.then3, label %if.follow4
if.then3:
	ret i32 0
if.follow4:
	%v11 = load i32, i32* %a.addr.3
	%v12 = getelementptr inbounds i32, i32* %v2, i32 0
	%v13 = load i32, i32* %v12
	%v14 = icmp ne i32 %v11, %v13
	br i1 %v14, label %if.then5, label %if.follow6
if.then5:
	%v15 = getelementptr inbounds i32, i32* %v2, i32 0
	%v16 = load i32, i32* %v15
	ret i32 %v16
if.follow6:
	store i32 0, i32* %i.addr.17
	br label %for.cond7
for.cond7:
	%v18 = load i32, i32* %i.addr.17
	%v19 = load i32, i32* %a.addr.3
	%v20 = icmp sle i32 %v18, %v19
	br i1 %v20, label %for.body8, label %for.follow10
for.body8:
	%v21 = load i32, i32* %b.addr.4
	%v22 = icmp eq i32 %v21, 0
	br i1 %v22, label %if.then11, label %if.follow12
for.update9:
	%v35 = load i32, i32* %i.addr.17
	%v36 = add i32 %v35, 1
	store i32 %v36, i32* %i.addr.17
	br label %for.cond7
for.follow10:
	%v37 = load i32, i32* %b.addr.4
	ret i32 %v37
if.then11:
	br label %for.follow10
if.follow12:
	%v23 = getelementptr inbounds i32, i32* %v2, i32 0
	%v24 = load i32, i32* %v23
	%v25 = icmp ne i32 %v24, 0
	br i1 %v25, label %if.then13, label %lor.rhs15
if.then13:
	br label %for.update9
if.follow14:
	%v27 = icmp ne i32 0, 0
	br i1 %v27, label %land.rhs18, label %if.follow17
lor.rhs15:
	%v26 = icmp ne i32 1, 0
	br i1 %v26, label %if.then13, label %if.follow14
if.then16:
	br label %for.follow10
if.follow17:
	%v31 = icmp ne i32 1, 0
	br i1 %v31, label %if.then19, label %lor.rhs21
land.rhs18:
	%v28 = load i32, i32* %a.addr.3
	%v29 = call i32 @shortPath(i32 %v28)
	%v30 = icmp ne i32 %v29, 0
	br i1 %v30, label %if.then16, label %if.follow17
if.then19:
	br label %for.follow10
if.follow20:
	br label %for.update9
lor.rhs21:
	%v32 = load i32, i32* %b.addr.4
	%v33 = call i32 @shortPath(i32 %v32)
	%v34 = icmp ne i32 %v33, 0
	br i1 %v34, label %if.then19, label %if.follow20
}

define dso_local i32 @sum(i32* %v0, i32 %v1) {
entry0:
	%n.addr.2 = alloca i32
	%sum1.addr.3 = alloca i32
	%i.addr.4 = alloca i32
	%j.addr.5 = alloca i32
	store i32 %v1, i32* %n.addr.2
	store i32 0, i32* %sum1.addr.3
	store i32 0, i32* %i.addr.4
	br label %for.cond1
for.cond1:
	%v6 = load i32, i32* %i.addr.4
	%v7 = load i32, i32* %n.addr.2
	%v8 = icmp slt i32 %v6, %v7
	br i1 %v8, label %for.body2, label %for.follow4
for.body2:
	%v9 = load i32, i32* %sum1.addr.3
	%v10 = load i32, i32* %i.addr.4
	%v11 = getelementptr inbounds i32, i32* %v0, i32 %v10
	%v12 = load i32, i32* %v11
	%v13 = add i32 %v9, %v12
	store i32 %v13, i32* %sum1.addr.3
	br label %for.update3
for.update3:
	%v14 = load i32, i32* %i.addr.4
	%v15 = add i32 %v14, 1
	store i32 %v15, i32* %i.addr.4
	br label %for.cond1
for.follow4:
	%v16 = icmp sgt i32 1, 2
	br i1 %v16, label %if.then5, label %if.follow6
if.then5:
	br label %for.cond7
if.follow6:
	%v36 = load i32, i32* %sum1.addr.3
	ret i32 %v36
for.cond7:
	%v17 = load i32, i32* %i.addr.4
	%v18 = load i32, i32* %n.addr.2
	%v19 = icmp slt i32 %v17, %v18
	br i1 %v19, label %for.body8, label %for.follow10
for.body8:
	br label %for.update9
for.update9:
	%v20 = load i32, i32* %i.addr.4
	%v21 = add i32 %v20, 1
	store i32 %v21, i32* %i.addr.4
	br label %for.cond7
for.follow10:
	br label %for.cond11
for.cond11:
	br label %for.body12
for.body12:
	br label %for.update13
for.update13:
	%v22 = load i32, i32* %i.addr.4
	%v23 = add i32 %v22, 1
	store i32 %v23, i32* %i.addr.4
	br label %for.cond11
for.follow14:
	br label %for.cond15
for.cond15:
	br label %for.body16
for.body16:
	br label %for.update17
for.update17:
	br label %for.cond15
for.follow18:
	store i32 0, i32* %i.addr.4
	br label %for.cond19
for.cond19:
	br label %for.body20
for.body20:
	br label %for.update21
for.update21:
	%v24 = load i32, i32* %i.addr.4
	%v25 = add i32 %v24, 1
	store i32 %v25, i32* %i.addr.4
	br label %for.cond19
for.follow22:
	br label %for.cond23
for.cond23:
	%v26 = load i32, i32* %i.addr.4
	%v27 = load i32, i32* %n.addr.2
	%v28 = icmp slt i32 %v26, %v27
	br i1 %v28, label %for.body24, label %for.follow26
for.body24:
	br label %for.update25
for.update25:
	br label %for.cond23
for.follow26:
	store i32 0, i32* %i.addr.4
	br label %for.cond27
for.cond27:
	%v29 = load i32, i32* %i.addr.4
	%v30 = load i32, i32* %n.addr.2
	%v31 = icmp slt i32 %v29, %v30
	br i1 %v31, label %for.body28, label %for.follow30
for.body28:
	br label %for.update29
for.update29:
	br label %for.cond27
for.follow30:
	store i32 0, i32* %i.addr.4
	br label %for.cond31
for.cond31:
	br label %for.body32
for.body32:
	br label %for.update33
for.update33:
	br label %for.cond31
for.follow34:
	store i32 0, i32* %i.addr.4
	store i32 0, i32* %j.addr.5
	br label %for.cond35
for.cond35:
	br label %for.body36
for.body36:
	br label %for.update37
for.update37:
	br label %for.cond35
for.follow38:
	%v32 = icmp sgt i32 1, 2
	br i1 %v32, label %if.then39, label %if.else41
if.then39:
	br label %if.follow40
if.follow40:
	store i32 1, i32* %i.addr.4
	%v33 = sub i32 0, 1
	store i32 %v33, i32* %i.addr.4
	%v34 = add i32 1, 1
	%v35 = sub i32 0, %v34
	store i32 %v35, i32* %i.addr.4
	store i32 1, i32* %i.addr.4
	br label %if.follow6
if.else41:
	br label %if.follow40
}

define dso_local i32 @main() {
entry0:
	%c0.addr.1 = alloca i32
	%c2.addr.2 = alloca [2 x i32]
	%c3.addr.5 = alloca i32
	%c11.addr.6 = alloca i32
	%c0.addr.7 = alloca i32
	%globalVar.addr.8 = alloca i32
	%a.addr.17 = alloca i32
	%a.addr.27 = alloca i32
	%b.addr.28 = alloca i32
	%c.addr.29 = alloca [2 x i32]
	%sum1.addr.32 = alloca i32
	%ans.addr.41 = alloca i32
	%v0 = getelementptr inbounds [10 x i8], [10 x i8]* @.str.0, i32 0, i32 0
	call void @putstr(i8* %v0)
	store i32 0, i32* %c0.addr.1
	%v3 = getelementptr inbounds [2 x i32], [2 x i32]* %c2.addr.2, i32 0, i32 0
	store i32 1, i32* %v3
	%v4 = getelementptr inbounds [2 x i32], [2 x i32]* %c2.addr.2, i32 0, i32 1
	store i32 2, i32* %v4
	store i32 3, i32* %c3.addr.5
	%v9 = icmp ne i32 1, 0
	br i1 %v9, label %if.then1, label %lor.rhs3
if.then1:
	store i32 1, i32* %c11.addr.6
	br label %if.follow2
if.follow2:
	%v11 = load i32, i32* %c0.addr.1
	%v12 = mul i32 %v11, 1
	%v13 = srem i32 %v12, 4
	%v14 = sdiv i32 %v13, 2
	call void @putint(i32 %v14)
	%v15 = getelementptr inbounds [2 x i8], [2 x i8]* @.str.1, i32 0, i32 0
	call void @putstr(i8* %v15)
	%v16 = icmp sge i32 1, 2
	br i1 %v16, label %if.then4, label %if.follow5
lor.rhs3:
	%v10 = icmp ne i32 1, 0
	br i1 %v10, label %if.then1, label %if.follow2
if.then4:
	%v18 = add i32 32, 2
	%v19 = sub i32 %v18, 1
	%v20 = load i32, i32* @globalVar
	%v21 = getelementptr inbounds [2 x i32], [2 x i32]* %c2.addr.2, i32 0, i32 1
	%v22 = load i32, i32* %v21
	%v23 = srem i32 %v22, 44
	%v24 = add i32 42, %v23
	%v25 = mul i32 %v20, %v24
	%v26 = add i32 %v19, %v25
	store i32 %v26, i32* %a.addr.17
	br label %if.follow5
if.follow5:
	store i32 2342, i32* %a.addr.27
	store i32 2323, i32* %b.addr.28
	%v30 = getelementptr inbounds [2 x i32], [2 x i32]* %c.addr.29, i32 0, i32 0
	store i32 10, i32* %v30
	%v31 = getelementptr inbounds [2 x i32], [2 x i32]* %c.addr.29, i32 0, i32 1
	store i32 10, i32* %v31
	store i32 1, i32* %sum1.addr.32
	%v33 = getelementptr inbounds [2 x i32], [2 x i32]* %c.addr.29, i32 0, i32 0
	%v34 = call i32 @sum(i32* %v33, i32 2)
	store i32 %v34, i32* %sum1.addr.32
	%v35 = load i32, i32* @globalVar
	%v36 = getelementptr inbounds [11 x i8], [11 x i8]* @.str.2, i32 0, i32 0
	call void @putstr(i8* %v36)
	call void @putint(i32 %v35)
	%v37 = getelementptr inbounds [2 x i8], [2 x i8]* @.str.1, i32 0, i32 0
	call void @putstr(i8* %v37)
	%v38 = load i32, i32* @globalVar1
	%v39 = getelementptr inbounds [11 x i8], [11 x i8]* @.str.2, i32 0, i32 0
	call void @putstr(i8* %v39)
	call void @putint(i32 %v38)
	%v40 = getelementptr inbounds [2 x i8], [2 x i8]* @.str.1, i32 0, i32 0
	call void @putstr(i8* %v40)
	store i32 1, i32* %ans.addr.41
	%v42 = load i32, i32* %a.addr.27
	%v43 = load i32, i32* %b.addr.28
	%v44 = getelementptr inbounds [2 x i32], [2 x i32]* %c.addr.29, i32 0, i32 0
	%v45 = call i32 @caculateFunc(i32 %v42, i32 %v43, i32* %v44)
	store i32 %v45, i32* %ans.addr.41
	%v46 = load i32, i32* %ans.addr.41
	%v47 = getelementptr inbounds [17 x i8], [17 x i8]* @.str.3, i32 0, i32 0
	call void @putstr(i8* %v47)
	call void @putint(i32 %v46)
	%v48 = getelementptr inbounds [2 x i8], [2 x i8]* @.str.1, i32 0, i32 0
	call void @putstr(i8* %v48)
	call void @declareFunc()
	%v49 = getelementptr inbounds [15 x i8], [15 x i8]* @.str.4, i32 0, i32 0
	call void @putstr(i8* %v49)
	call void @putint(i32 0)
	%v50 = getelementptr inbounds [2 x i8], [2 x i8]* @.str.1, i32 0, i32 0
	call void @putstr(i8* %v50)
	%v51 = getelementptr inbounds [3 x i8], [3 x i8]* @.str.5, i32 0, i32 0
	call void @putstr(i8* %v51)
	%v52 = getelementptr inbounds [3 x i8], [3 x i8]* @.str.6, i32 0, i32 0
	call void @putstr(i8* %v52)
	%v53 = getelementptr inbounds [3 x i8], [3 x i8]* @.str.7, i32 0, i32 0
	call void @putstr(i8* %v53)
	%v54 = load i32, i32* %sum1.addr.32
	%v55 = getelementptr inbounds [6 x i8], [6 x i8]* @.str.8, i32 0, i32 0
	call void @putstr(i8* %v55)
	call void @putint(i32 %v54)
	%v56 = getelementptr inbounds [2 x i8], [2 x i8]* @.str.1, i32 0, i32 0
	call void @putstr(i8* %v56)
	ret i32 0
}